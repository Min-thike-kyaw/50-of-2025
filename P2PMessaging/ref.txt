// File: server.js (Node.js signaling server)
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

const rooms = {}; // { roomId: Set of socket IDs }

io.on('connection', (socket) => {
    socket.on('join-room', ({ roomId, userId }) => {
        socket.join(roomId);
        socket.roomId = roomId;
        socket.userId = userId;

        if (!rooms[roomId]) rooms[roomId] = new Set();
        rooms[roomId].add(socket.id);

        socket.to(roomId).emit('new-user', { socketId: socket.id, userId });
    });

    socket.on('signal', ({ to, data }) => {
        io.to(to).emit('signal', { from: socket.id, data });
    });

    socket.on('disconnect', () => {
        const roomId = socket.roomId;
        if (roomId && rooms[roomId]) {
            rooms[roomId].delete(socket.id);
            socket.to(roomId).emit('user-left', { socketId: socket.id });
            if (rooms[roomId].size === 0) delete rooms[roomId];
        }
    });
});

app.use(express.static('public'));

server.listen(3000, () => console.log('Server running on http://localhost:3000'));

/*
Directory structure:
project/
├── server.js
├── public/
│   ├── index.html
│   └── script.js
*/

// File: public/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Mesh Video Chat</title>
</head>
<body>
  <h1>WebRTC Mesh Call</h1>
  <video id="local" autoplay playsinline muted></video>
  <div id="remote-container"></div>
  <script src="/socket.io/socket.io.js"></script>
  <script src="script.js"></script>
</body>
</html>

// File: public/script.js
const socket = io();
const localVideo = document.getElementById('local');
const remoteContainer = document.getElementById('remote-container');
const peers = {};
let localStream;
const roomId = new URLSearchParams(window.location.search).get('room');
const userId = crypto.randomUUID();

(async () => {
  localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
  localVideo.srcObject = localStream;

  socket.emit('join-room', { roomId, userId });
})();

socket.on('new-user', async ({ socketId }) => {
  const pc = createPeer(socketId);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  socket.emit('signal', { to: socketId, data: { type: 'offer', sdp: pc.localDescription } });
});

socket.on('signal', async ({ from, data }) => {
  let pc = peers[from] || createPeer(from);

  if (data.type === 'offer') {
    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.emit('signal', { to: from, data: { type: 'answer', sdp: pc.localDescription } });
  } else if (data.type === 'answer') {
    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
  } else if (data.type === 'ice') {
    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
  }
});

function createPeer(socketId) {
  const pc = new RTCPeerConnection();

  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  pc.onicecandidate = e => {
    if (e.candidate) {
      socket.emit('signal', { to: socketId, data: { type: 'ice', candidate: e.candidate } });
    }
  };

  pc.ontrack = ({ streams: [stream] }) => {
    let remote = document.getElementById(`remote-${socketId}`);
    if (!remote) {
      remote = document.createElement('video');
      remote.id = `remote-${socketId}`;
      remote.autoplay = true;
      remote.playsInline = true;
      remoteContainer.appendChild(remote);
    }
    remote.srcObject = stream;
  };

  peers[socketId] = pc;
  return pc;
}

socket.on('user-left', ({ socketId }) => {
  const video = document.getElementById(`remote-${socketId}`);
  if (video) video.remove();
  if (peers[socketId]) {
    peers[socketId].close();
    delete peers[socketId];
  }
});
